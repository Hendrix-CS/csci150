<html>
<head>
  <title>CSCI 150 - Lab 13 - Eliza the Chatterbot</title>
  <link rel="stylesheet" type="text/css" title="Default" href="../style.css">
</head>

<body>
<h1><a href="../index.html">CSCI 150</a> - Lab 13<br>Eliza the Chatterbot</h1>

<h2>Materials</h2>
<ul>
  <li><a href="https://docs.python.org/2/library/re.html">Regular Expressions Module</a></li>
  <li><a href="../code/chatterbot.py">ChatterBot Code</a></li>
</ul>

<h2>Overview</h2>
One essential piece of computer science we have explored this semester has been
communication with the computer. Programming languages can be exacting and tedious,
and much work has been done to teach a computer to understand natural languages 
such as English.
<p>
Early efforts in this area were in the form of 
<a href="https://en.wikipedia.org/wiki/Chatterbot">Chatterbots</a>,  a famous example
being <a href="https://en.wikipedia.org/wiki/ELIZA">ELIZA</a>, a computational
psychotherapist. While not terribly complex, Eliza was able to have plausible interactions
and convince users of her ability to understand the conversation.
<p>
More recently, with advanced algorithms in statistical pattern matching and 
natural language processing, we have seen the rise of 
<a href="http://www.apple.com/ios/siri/">Siri</a>,
<a href="http://windows.microsoft.com/en-us/windows-10/getstarted-what-is-cortana">Cortana</a>,
<a href="https://www.google.com/landing/now/">Google Now</a>, and
<a href="http://www.amazon.com/Amazon-SK705DI-Echo/dp/B00X4WHP5E">Alexa</a>.
<p>
Today we will learn some of the basics of pattern matching with
regular expressions and building a chatterbot.

<h2>Step 1 - Chatter</h2> 
To get started, we have provided you with the basic framework for a text-based chatterbot.
Download the 
<a href="../code/chatterbot.py">chatterbot.py</a> file and load it up in IDLE.
You should be able to have a very limited conversation with Eliza.

<h3>Task 1.1</h3>
Add a component to the <tt>Eliza</tt> class that is a list of at least 5 possible
responses.
<p>
Alter the <tt>get_response</tt> method to choose a random response from this list
and return the chosen string.
<p>
Test your code to make sure you get random responses in your conversation.

<h2>Step 2 - Find All Matches </h2>
To make our conversation more interactive, we need to have Eliza respond to the 
content of the <tt>text</tt> parameter of our <tt>get_response</tt> method. Using
the skills we currently have in Python, we could
try to match exact strings, but this would be too brittle and not account for the 
various ways we could say the same thing.  
<p>
Alternatively, we could try to
find if a string is a substring of <tt>text</tt>.
For example if we are looking for a conversation on cats, we could write
<p>
<pre>if "cat" in text:</pre>
<p>
This would find all places of the substring cat, even if the text was 
<tt>"catastrophe"</tt>. We could also look for <tt>"kitten"</tt>, <tt>"kitty"</tt>,
etc., but this would easily become a long and complicated if statement.
<p>
Python, like most programming languages, includes a module to help with this
pattern matching, called 
<a href="https://docs.python.org/2/library/re.html">Regular Expressions</a>.
<p>
In the shell, import the regular expression module, by typing
<p>
<pre>import re</pre>
<p>
Every string is a regular expression, and we can prefix it with an <tt>r</tt> to
indicate this. The function <tt>re.findall</tt> takes two parameters, the pattern
to search for, and the text where it should be found. It will return a list
of all matches found.
<p>
<p>
<pre>re.findall(r"cat", "I like cats.")</pre>
<p>
But regular expressions are much more powerful than just strings.
We can easily combine multiple things for a match with the pipe symbol <tt>|</tt>.
Test our the following command to see what it returns.
<p>
<p>
<pre>re.findall(r"a|b|c", "abracadabra")</pre>
<p>
And we can search for larger patterns by using parenthesis.
<p>
<pre>re.findall(r"(c(a|o)t)", "There is a cat on the cot")</pre>
<p>
Each set of parenthesis becomes a portion of the match. Compare the above regular
expression to the following one.
<p>
<pre>re.findall(r"(c|a)(o|t)", "There is a cat on the cot")</pre>
<p>
We can also generalize our strings into patterns, such as alphabetic characters
or digits. 
To look for the alphanumeric characters in a given text string, we can use 
<tt>\w</tt>.
<p>
<pre>re.findall(r"\w", "I like the numbers 12 and 47!")</pre>
<p>
To look for the digits in a given text string, we can use 
<tt>\d</tt>.
<p>
<pre>re.findall(r"\d", "I like the numbers 12 and 47!")</pre>
<p>
This returns the individual digits 1, 2, 4 and 7. Not exactly what we were hoping for.
To match a continuous repeating pattern, there are two options, the 
<tt>+</tt> and the <tt>*</tt> symbols. + will match 1 or more repetitions of the 
pattern, while * will match 0 or more.
<p>
<pre>re.findall(r"\w+", "I like the number 12 and 47!")</pre>
<p>
<pre>re.findall(r"\d+", "I like the number 12 and 47!")</pre>
<p>
<pre>re.findall(r"\d*", "I like the number 12 and 47!")</pre>
<p>

<h3>Task 2.1</h3>
Write a concise regular expression to look for any of the following words
<p>
<ul>
cat, kit, kitten, kitty
</ul>
<p>
Alter your <tt>get_response</tt> method to look for this regular expression in 
the <tt>text</tt> parameter. If the list is not empty, you know there was a match
found, so you can return an appropriate response. Otherwise, return a random
response as above.

<h2>Step 3 - Tailored Responses</h2>
To make our responses more aligned with the exact match found in the conversation, 
we can use the <tt>sub</tt> function. There are now three parameters, the first
is still the pattern, the last is the text to search, and the middle is 
a replacement regular expression to return when a match is found.
<p>
<pre>match = re.sub(r"I('m| am) (sad|\w+py)",
                           r"Why are you \2?",
                           text)
</pre>
<p>
<h2>Step 4 - Memory</h2>
Often, it will be useful to have a chatterbot move beyond a reflexive response. To 
add a memory to your chatterbot, you will need to give it more components in the 
<tt>__init__</tt> method, and then alter these components when a response is relevant.
These could be Booleans, string, integers, however you want to track the state of 
your conversation.
<h3>Task 4.1</h3>
You want to remember that the user is interested in cats, you could add
a Boolean to track this.
<p>
<pre>self.catlover = False</pre>
<p>
When the if statement you wrote in Task 2.1 is true, flip this flag to <tt>True</tt>.
<p>
Now, when Eliza does not find a match in the conversation for her topics, if
she knows that the user is a cat lover, she should reply with random
cat questions or 
<a href="http://knowyourmeme.com/memes/events/cat-facts-text-trolling">facts</a>.

<h2>Step 5 - Personal Chatterbot</h2>
Create a new chatterbot with a name and a distinct personality as a subclass
of <tt>Chatter</tt>. Your new chatterbot should have the ability to discuss
at least four different topics of conversation, and have at least 25 unique responses
for the user.
<h2>What to Hand In</h2>
Turn in your completed <tt>chatterbot.py</tt> file on Moodle.
<h2>Grading</h2>
<ul>
  <li>To earn a D on this lab, complete Step 1 and 2.</li>
  <li>To earn a C on this lab, do all the above and complete Step 3.</li>
  <li>To earn a B on this lab, do all the above and complete Step 4.</li>
  <li>To earn an A on this lab, do all the above and complete Step 5.</li>
  <li>To earn a 100 on this lab, do all the above and complete at least six different topics and 
  have at least 35 unique responses.</li>
</ul>

<hr>
<small>&copy; Mark Goadrich and Brent Yorgey, Hendrix College</small>
</BODY>
</HTML>
