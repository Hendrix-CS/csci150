% -*- compile-command: "pdflatex class-notes.tex" -*-

\documentclass{article}

\usepackage{hyperref}

\begin{document}

\title{CSCI 150: Foundations of Computer Science \\ Fall 2015 Lecture Notes}

\maketitle

\section{Introduction (Wednesday, 26 August)}

\subsection*{Setup}

\begin{itemize}
\item Music: Copland, Fanfare for the Common Man
\item Meet students.
\item Introduce myself.
\item Have students meet each other. (Name, where from, why taking
  this class, one of your favorite things.)  Prize for first student
  to know all names.
\end{itemize}

\subsection*{What is Computer Science?}

This class is Foundations of Computer Science.  What is Computer
Science?  Look at each component separately.
\begin{itemize}
\item \textbf{What is a computer?}  Get some responses.
\item \textbf{What do computers do?}  Lots of things.  Commonality:
  information.  Communicating, transforming, analyzing, storing.
\item \textbf{What is science?}  Get some responses.  Scientists use
  rational investigation \& analysis, mathematics, etc. to study the
  natural world.
\end{itemize}

So what do computer scientists study?  \textbf{NOT computers!}
Rather, \textbf{information} = anything that can be expressed digitally,
i.e. with numbers/symbols.  ``Computer science'' is actually a bad
name, \emph{cf.}\ ``telescope science''.  Information structure of the
universe.

Why study it?  (Maybe get some student responses)
\begin{itemize}
\item Beautiful ideas, new ways of thinking.
\item Many applications!  Can contribute directly to human flourishing.
\item Computers are everywhere.  Understanding principles of CS =
  being an informed, engaged citizen.
\end{itemize}
Could do this without a computer, but computers are excellent enabling
tools.

\href{https://www.youtube.com/watch?v=qYZF6oIZtfc}{\textbf{Watch code.org video}}.

\subsection*{Administrivia}

\begin{itemize}
\item Syllabus review online.
\item Academic integrity.
\item BYOL.
\item Moodle.
\item Office hours.
\item Remember to come to lab!
\end{itemize}

For next time:

\begin{itemize}
\item Read chapter 1 of textbook.
\item Do HW 0, ``who are you'', if not already done.
\end{itemize}

\subsection*{Scratch intro}

Basic intro to Scratch for first lab.

\newpage

\section{Algorithms and language (Friday, 28 August)}

\subsection*{Setup}

\begin{itemize}
\item Music: Attaboy from Goat Rodeo Sessions. 5:42.  Start at 8:04.
\item Bring origami paper.
\end{itemize}

\subsection*{Administrivia}

\begin{itemize}
\item I will be gone next week.  ICFP.  Functional Programming ---
  super cool.  Really get to see intersection of math \& CS. Take CSCI
  490 in the spring (with MATH 240)!
\item In my place, Connor Bell will be lecturing \& will introduce you
  to Python.  Please show him the same respect you would show me!
\item Please download Python for Monday.  (Show python website, linked
  from our webpage.  Use version 2.7.)  \textbf{Bring your laptop!}
\end{itemize}

\subsection*{IRC}

Show IRC channel. Explain what it is for. Explain ground rules. Have
everyone log in \& try it out.

\subsection*{Reading review}

\begin{itemize}
\item Review 5 aspects of algorithms (input, output, math,
  conditionals, repetition).  Where did we see them in Scratch? Didn't
  use conditionals but saw the others.
\item Review 3 kinds of errors (syntax, semantic, runtime).  Talk
  about each in context of Scratch (doesn't have syntax errors !!!; lots
  of semantic errors; runtime = running into wall)
\item Fact that Scratch doesn't have syntax errors is a Really Big
  Deal.  Imagine if when learning a foreign language, every time you
  made even a small grammatical mistake the other person just cut you off and
  said ``I don't understand.''  That's what it will feel like learning
  Python.  So don't be discouraged---remember what you could do with
  Scratch.  You'll get there with Python too.
\item Talk about formal vs natural languages, tokens, parsing
\end{itemize}

\textbf{Quiz Monday on Chapter 1}.

\subsection*{Collatz Conjecture}

\begin{itemize}
\item Write out hailstone function.
\item Note all 5 aspects of algorithm.
\item Try it on some inputs: 4, 8, 6, 11. Draw a tree etc.  Try 27,
  realize we need a computer.
\item Simple algorithms can have very surprising results!  Visit
  Wikipedia page.
\end{itemize}

\subsection*{Origami}

\begin{itemize}
\item Explain what we are going to do: make a dinosaur.
  \begin{itemize}
  \item Everyone will be able to do it by the end of class.
  \item Then write instructions IN ENGLISH and find a confederate to
    follow them.  Can't show them image or video, or your dinosaur.
    Can't help interpret your instructions.  Just tell them to keep
    going as well as they can and get to the end.
  \item Monday: turn in both dinosaurs in class.  Turn in your
    instructions \& writeup on Moodle.
  \end{itemize}

\item Hand out origami paper.
\item Show video \& instruction image on the screen at the same time.
\item Wander around and make sure everyone can do it.
\end{itemize}

\section{XXX}

\section{XXX}

\section{XXX}

\newpage
\section{Conditionals (Wednesday, 9 September)}

\subsection*{Setup}

\begin{itemize}
\item Music: Whitacre ``i thank You God''. 6:56.  Start at 8:03.
\item Talk about Fabienne Serriere.  Show website.
\item Collect puzzle HW.
\end{itemize}

\subsection*{Quiz}
\textbf{Quiz 2}

We saw Boolean values {\tt True} and {\tt False}, in the puzzles, with
operators {\tt and}, {\tt or}, {\tt not} last time.  How else can we get
Booleans?

\textbf{Comparison operators}: \verb|>|, \verb|<|, \verb|>=|,
\verb|<=|, \verb|!=|, \verb|==|.  Demonstrate on numbers, strings, all
generate Booleans.

Now, the computer has a basis to make decisions.  Sets up branches in
the code, execute this or that.

\begin{verbatim}
passwd = input("What is the password? ")
if (passwd == "lemur"):
    print "Here be secrets."
\end{verbatim}

Tabbing is important!  Colon is important!

Introduce random module. ({\tt from random import *})
\begin{itemize}
\item {\tt random()} is number in $[0,1)$. Uniform.
\item {\tt randint(n)} is random integer between $0$ and $n$
  (inclusive).  (Aside: how can we write this in terms of {\tt
    random()}?)
\end{itemize}
Do coin flip.  Conditionally do... something.  Needs to include
\begin{itemize}
\item {\tt else}
\item {\tt elif}
\item nested {\tt if}  (flip two coins in a row)
\end{itemize}

\newpage
\section{Information encoding I (Friday, 11 September)}

\subsection*{Setup/administrivia}

\begin{itemize}
\item Music: Dave Brubeck Quartet, Kathy's Waltz
\item NB: exam 1 a week from today.  In class, closed notes, closed
  computer.  Covers material through today and Monday.  Wednesday will
  be exam review.
\item Collect any remaining logic puzzle HW!
\end{itemize}

\subsection*{Ada Lovelace}

How many of you have heard of Ada Lovelace?  How about Charles
Babbage?

Ada Lovelace: 1815 (December 10!)--1852, first programmer.  Wrote
programs for Charles Babbage's Analytical Engine (never built, but
definitely works in principle).  Babbage's purpose for the AE was
limited to making tables of numbers, but Lovelace had a much more
expansive and far-seeing vision:

\begin{quote}
``[The Analytical Engine] might act upon other things besides number,
were objects found whose mutual fundamental relations could be
expressed by those of the abstract science of operations, and which
should be also susceptible of adaptations to the action of the
operating notation and mechanism of the engine...

Supposing, for instance, that the fundamental relations of pitched
sounds in the science of harmony and of musical composition were
susceptible of such expression and adaptations, the engine might
compose elaborate and scientific pieces of music of any degree of
complexity or extent.''
\end{quote}

She saw potential for computers to operate on many kinds of
information instead of just making tables of numbers.  Over the next 2
classes we will consider some of the fundamentals that make this
possible.

\subsection*{Binary}

Computers represent numbers using \emph{binary} = base 2 instead of
base 10.  Recall how base 10 works: ones ($=10^0$) place, tens
($=10^1$) place, hundreds ($=10^2$) place, \dots  And ten different
digits.  For example \[ 4397_{10} = 4 \times 10^3 + \dots \] Base 2 is
the same but
\begin{itemize}
\item We use $2$ instead of $10$ (ones place, 2's place, 4's place,
  8's place\dots)
\item We use $2$ digits $(0,1)$ instead of $10$.  Called \emph{bits} =
  \emph{bi}nary dig\emph{its}.
\end{itemize}
Computers do everything in binary since (1) it is no less expressive
than e.g. decimal and (2) from a physical point of view, it is easier
to design hardware that can distinguish two different states
(e.g. high and low voltage) than 10.

Converting base $2$ to base $10$: have them do some
examples. e.g. $10110100_2 = ?$  Then do one example together on the
board, \[ 10110100_2 = 1 \times 2^7 + 1 \times 2^5 + \dots \]

Note 1 \emph{byte} = 8 bits.  Incidentally, one \emph{kilobyte} is not
$1000$ bytes, but actually $2^{10} = 1024$ bytes!  Megabyte is
$2^{20}$ bytes, and so on.

Questions for students (pair \& share etc):
\begin{enumerate}
\item How many different binary numbers using $n$ bits are there?
  (Write out 16 binary numbers using $4$ bits.)
\item What is the biggest number that can be represented using $n$
  bits?
\item How many bits are required to count up to $n$?
\end{enumerate}

Algorithm for converting from $n$ in base $10$ to binary:
\begin{itemize}
\item Find largest power of two $\leq n$, say, $2^k$.
\item As long as $n > 0$:
  \begin{itemize}
  \item If $2^k \leq n$, subtract $2^k$ from $n$ and write a $1$
    (in the $2^k$ place). Else, write a $0$.
  \item Decrease $k$ by $1$.
  \end{itemize}
\end{itemize}

(This has all five usual aspects of algorithms: input, output, math,
conditionals, repetition.  We can't quite write this algorithm in
Python yet because we don't know how to do repetition.  Soon!)  Do an
example, e.g. $103_{10}$.

\subsection*{Representing integers}

Integers are represented like this inside the computer.  Show entering
binary numbers directly into Python using \verb|0b10110| notation.

Most modern computers use $64$ bits to represent an integer (\emph{how
  big is that?}); some use $32$. Show Python switching from \verb|int|
to \verb|long|:
\begin{itemize}
\item Some small and very big examples
\item \verb|2**62|
\item \verb|2**63|
\item Apply \verb|type| to each of the above.
\end{itemize}

What about negative numbers?  One possibility: use one bit for sign
(plus or minus).  (Turns out there is a better way, ``$2$'s
complement''; learn about it in CSO or ask if you are curious.)

\newpage
\section{Information encoding II (Monday, 14 September)}

\subsection*{Setup}
\begin{itemize}
\item Music: ?
\item Quiz 3
\end{itemize}

\subsection*{Representing floating-point numbers}

Back to base $10$: what does $123.45$ mean?
\[ \dots + 4 \times 10^{-1} + 5 \times 10^{-2} \]
We can do binary ``decimals'' (``binarals''?) the same way: \[
1101.011 = 1 \times 2^3 + \dots + 1 \times 2^{-1} + 1 \times 2^{-2} =
13 \frac{3}{8} \]  Also recall ``scientific notation'', e.g. $1.23
\times 10^{17}$.  This is how ``floating point'' numbers are
represented: scientific notation, but in base $2$.  For example, with
$64$ bits:
\begin{itemize}
\item 1 bit for sign ($\pm$)
\item $11$ bits for exponent (base $2$ integer)
\item $52$ bits for value
\end{itemize}
e.g. $-1011011 \times 2^{-3}$.

How would you represent $0.1_{10}$?  Can't represent exactly using
base $2$ (infinite)! Show $0.1 + 0.1 + 0.1$ at python prompt.

\subsection*{Representing text}

Basic idea: use a different number to represent each letter.  ASCII
(American Std. Code for Info. Exch.) --- early 1960's.  Specified
$128$ different characters, each using $7$ bits.  (In many cases 1 bit
left over for parity checking or just set to $0$.)
\begin{itemize}
\item Show ASCII chart.
\item Illustrate chr and ord functions in python.
\end{itemize}
$128$ characters may have been enough for the white, American,
English-speaking men who made it up.  But it sure isn't any more.
Unicode---currently over 120,000 characters. (How many bits needed?
Often uses a more complex scheme to allow different numbers of bits,
\& extending indefinitely without changing existing.  Ask if you're
curious.)

\subsection*{Representing images}

Image = grid of colored points (``pixels'' = \emph{pic}ture
\emph{el}ements).  Each pixel = mix of red, green, blue (additive
primary colors).  Each primary color has 256 possible intensities,
from 0 (off) to 255 (as bright as possible).  So each primary = 8 bits
(1 byte), each pixel = 24 bits.  How many bits/bytes for a $500 \times
500$ image?

\subsection*{Hexadecimal}

Base $16$.  Need 16 symbols: 0--9, a--f. So $a_{16} = 10_{10}$ and so
on. $\mbox{ace}_{16} = ?$

Note, we can group the binary digits into 4s.  $16 = 2^4$.  So each 4
bits corresponds to 1 hexadecimal digit.  Conversion back and forth is
super easy.  We often use hexadecimal as a more convenient way to read
and write binary.  Easier for humans to read and remember.

Show entering hexadecimal directly into Python using \verb|0xace|
notation.

Show example of RGB colors expressed in hexadecimal: show
\verb|style.css| from course website.

\newpage

\section{Exam 1 review (Wednesday, 16 Sep)}

Have them do sample exam. Go over it.  Things to emphasize:
\begin{itemize}
\item ``Semantic errors'': looking for explanation of how/why the
  program works.
\item Don't just print out a number, print it with a nice message!
\item \dots
\end{itemize}

\section{Exam 1 (Friday, 18 Sep)}

\newpage

\section*{Functions I (Monday, 21 Sep)}

\subsection*{Setup}
\begin{itemize}
\item Music: Darlingside ``Good Man''
\item Lovelace \& Babbage: prize for whoever can say names of all
  classmates on two separate occasions
\end{itemize}

\subsection*{Exam 1 review}
\begin{itemize}
\item Hand back exams.
\item Go over some solutions:
  \begin{itemize}
  \item Write exemplar solution for programming question
  \item Go over semantic errors question
  \item Come ask me or Dr. Goadrich with questions about other problems.
  \end{itemize}
\end{itemize}

\subsection*{Project overview}

Show them the project.  Calendar strangeness due to tracking floating
point value (ratio of revolution to rotation) using integers!

\subsection*{Functions}

\textbf{Read Chapter 5! Note quiz on Wednesday!}

We have used functions in Python already, like \verb|raw_input|,
\verb|cos|?, other math things?

We can define our own functions!  Same rules for names as
variables. Header line: parens mean no inputs, colon, indent.  Stuff
inside the indent (body) says what happens.

\begin{verbatim}
def say_hi():
    print "Hello there, CSCI 150!"
    print "This is a function."
\end{verbatim}

Function definition makes a variable which is a function object. (Note
hex value in output! =) To call it, use parentheses.

Functions can be used inside other functions.

\begin{verbatim}
def say_hi_twice():
    say_hi()
    say_hi()
\end{verbatim}

Put things inside a script.  Note the definition itself does not cause
body to be executed.  Note functions must be defined before they are
used.

\subsection*{Why functions?}

Get them to discuss why this is a worthwhile feature.  Why define
functions?  Pair \& share.

From Downey:

\begin{itemize}
\item Creating a new function gives you an opportunity to name a group
  of statements, which makes your program easier to read and debug.
\item  Functions can make a program smaller by eliminating repetitive code.
  Later, if you make a change, you only have to make it in one place.
\item Dividing a long program into
  functions allows you to debug the parts one at a time and then
  assemble them into a working whole.
\item Well-designed functions are often useful for many programs.
  Once you write and debug one, you can reuse it.
\end{itemize}

\subsection*{Parameters and arguments}

Make C to F conversion into function, takes C as argument:
\begin{verbatim}
def C_to_F(temp_C):
    F = C * 9.0 / 5.0 + 32
    print "The temperature in degrees Fahrenheit is ", F
\end{verbatim}

\verb|temp_C| is a variable called a \emph{parameter}.

The values given to functions are called \emph{arguments}.  To call a
function, give one argument for each parameter.  The parameter will
stand for the argument.  Do some examples.  Note you can put arbitrary
expressions for arguments.

Variables created inside functions are local!  Parameters are also
local. Note that \verb|F| and \verb|temp_C| are not defined afterwards.

\section*{Functions II (Wednesday, 23 Sep)}

\subsection*{Setup/administrivia}
\begin{itemize}
\item Music: Holst Jupiter
\item Send me your exam grades!
\item Does anyone know all their classmates' names?
\end{itemize}

\subsection*{Quiz: arguments \& parameters}

\subsection*{Fruitful functions}

Recall function from last time:
\begin{verbatim}
def C_to_F(temp_C):
    F = C * 9.0 / 5.0 + 32
    print "The temperature in degrees Fahrenheit is ", F
\end{verbatim}
This function is actually really awkward.  Takes \verb|temp_C| as a
parameter, but then \emph{prints} the result.  What if we want to
compute this but not print anything?  Make each function do ONE job.
Better:
\begin{verbatim}
def C_to_F(temp_C):
    F = C * 9.0 / 5.0 + 32
    return F
\end{verbatim}
Book calls it a \emph{fruitful function}.  (As a mathematician I would
just call it a \emph{function}\dots) Note we could also get rid of the
\verb|F| and just return the whole expression; matter of
taste/experience.

\verb|return| means ``stop execution of the function right now and
return this value''.  What will this do?

\begin{verbatim}
def C_to_F(temp_C):
    F = C * 9.0 / 5.0 + 32
    return F
    print "The temperature is", F
\end{verbatim}

OK to have multiple return statements.  Let's try a function to tell
us about the temperature (\emph{do something like this, students can
  come up with details}):
\begin{verbatim}
def F_to_qualitative(temp_F):
    if F < 32:
        return "freezing"
    elif F < 50:
        return "cold"
    elif F < 75:
        return "warm"
    elif F < 90:
        return "hot"
    else:
        return "scorching"
\end{verbatim}

Functions can take multiple parameters.

\begin{verbatim}
def is_divisible(x, y):
    if (x % y == 0):
        return True
    else:
        return False
\end{verbatim}

Try some examples.  Note this is actually written in a redundant way.  We
can just return \verb|x % y == 0| directly.

\subsection*{Flow of execution \& stack diagrams}

Execution starts at the first line of a program and continues.  But
when a function is called, execution jumps to that function, and when
done picks back up where it left off.  This can get complicated, since
functions can call other functions!  In general Python has to keep
track of a ``stack'' of places to resume.  Imagine you were reading a
book but it told you to go read another book and then come back.  Then
THAT book told you to go read another book, etc.  You would keep the
old books, with bookmarks, in a pile.  When done, pick up the next
book from the top of the pile and continue.

Do an example. Write a function that calls \verb|C_to_F| on several
temperatures.  Then write another function which does that twice, and
so on.  Then trace execution.  Introduce an error and see the
``traceback''.  Draw a stack diagram with local variables.

\section*{While loops (Friday, 25 Sep)}

\subsection*{Setup}
\begin{itemize}
\item Music: Carmina Burana
\item Announce TAs!
\item Reminder: Project 1 due today
\item Announce office hours after class---projects
\item Anyone know classmates' names?
\end{itemize}

\subsection*{Guess my number game}

\begin{itemize}
\item First, play the game with class.
\item Try writing a program to play it (human guesses). Have to
  replicate code\dots?
\end{itemize}

\subsection*{While loops}

Introduce while loops.  Explain basics of how they work.
Using them, three important things:
\begin{itemize}
\item Declare and initialize variable(s) you need
\item Write the condition with those variables
\item Change those variables somewhere in the loop
\end{itemize}

Do a few examples.
\begin{itemize}
\item Count from 1 to 10.
\item Keep printing ``hi'' until user wants to stop --- have students
  write this code together on their computers.  Then have two or three
  share code?
\end{itemize}

Back to Guess My Number.  Introduce a loop.  Make hi/lo checking into
a function.  Promise: after we learn a bit more about strings we can
make another function to get valid int input from user in a loop.

\textbf{Homework} (due Monday): write version where computer guesses!

\section*{Strings (Monday, September 28)}

\subsection*{Setup}
\begin{itemize}
\item Music: Giant Steps
\item Classmates' names?  New rules: MOST by end of semester
\item Show dinosaur comic: \url{http://www.qwantz.com/index.php?comic=2883}
\end{itemize}

\subsection*{Guess My Number review}

Open code from last time.  Talk about modifying it for other version.

Remember:
\begin{itemize}
\item Variables are local!
\item No recursion, just loops.  Talk about recursion later.
\end{itemize}

\subsection*{Strings}

We sort of know about strings, but the only thing we can do with them
so far is concatenate them with \verb|+|.

\begin{itemize}
\item Strings are \emph{sequences of characters}.

\item We can reference individual characters in a string by their
  \emph{index}: \verb|mystring[3]|.  Note that \emph{indices start at 0}.

\item We can calculate the length of a string with \verb|len()|.
  (Relationship of \verb|len| to valid indices?)

\item String slices: \verb|mystr[a:b]|.  Have students play around to
  figure out details?
  \begin{itemize}
  \item Characters starting at index $a$, up to \emph{but not
      including} index $b$.
  \item Can leave off first, or second, or both.
  \item Negative indices count backwards from the end.
  \end{itemize}

\item We've seen \verb|+|: concatenation.
\item \verb|*| does repetition.

\item Strings have \emph{methods}, i.e. functions you can call on
  strings.  Do \verb|help(str)|, \verb|help(str.upper)| etc.
\item Show some useful meethods: \verb|upper|, \verb|count|,
  \verb|replace|, \verb|find|, \verb|isdigit|
\end{itemize}

\subsection{More while loop \& function practice}

First, function to ``explode'' a string.  Write it collaboratively.

\begin{verbatim}
def explode(s):
    i = 0
    while i < len(s):
        print s[i]
        i += 1
\end{verbatim}

Even better if they make some bugs in the above, run it and see what
is wrong.

\section*{While loop \& string practice (Wednesday, Sep 30)}

\subsection*{Setup}
\begin{itemize}
\item Music:
\item Show next dinosaur comic
\item Classmate names record to beat: 7 (Mason)
\item Lab today/tomorrow.  Not easy!  Please take the pre-coding
  design component seriously.
\end{itemize}

\subsection*{More while loop practice}

Start using docstrings.  From now on they should always write them for
their functions.  Show them that we can type \verb|help(int_input)| at
a prompt.
\begin{verbatim}
def int_input(prompt):
    """Repeatedly prompt the user for a number using the
    given prompt, until they enter a valid integer.
    """
    valid = False
    while (not valid):
        uinput = raw_input(prompt)
        if uinput.isdigit():
            valid = True
        else:
            print "That's not a valid integer"
    return int(uinput)
\end{verbatim}

Do version of \verb|int_input| that accepts negative numbers as well.

\begin{verbatim}
import time
def countdown(n):
    """Count down from n to zero."""
    while n > 0:
        print str(n) + "..."
        time.sleep(1)
        n = n - 1
    print "BLASTOFF!"
\end{verbatim}

Talk about \verb|n -= 1| syntax (``decrement'') and \verb|n += 1|
(``increment'').  Can also use \verb|*=|, \verb|/=| etc.

Collatz Conjecture.  Idea: write a program to test the conjecture.
What functions will we need?  Bottom-up approach.  Write each function
and then test it independently.  (Use docstrings.)
\begin{verbatim}
def hailstone(n):
    if n % 2 == 0:
        return (n/2)
    else:
        return (3*n + 1)

def collatz(n):
    count = 0
    while n != 1:
        n = hailstone(n)
        count += 1
    return count

def check_collatz_up_to(max):
    n = 1
    while n <= max:
        print n, collatz(n)
        n += 1
\end{verbatim}

(What happens if we take out \verb|max| check and just say
\verb|while true|?  A legitimate use of an infinite loop!)

\newpage
\section*{Lists I (Friday, 2 Oct)}

\subsection*{Setup}
\begin{itemize}
\item Music: Melody of Rhythm
\item Open Quiz 5 form
\item Hand back HW \& quiz
\item Distribute binary cards.  Learn the name of 0-bit pairing.
\end{itemize}

\subsection*{Quiz 5 (Strings)}

\subsection*{Lab (Doublets) review/hints}

1-bit pairing with binary cards and discuss lab.  Questions?

\subsection*{Lists}

Lists are a lot like strings, but hold arbitrary data instead of
characters.
\begin{itemize}
\item \verb|[]| is the empty list, like \verb|""| is the empty string
\item Can hold numbers, strings, anything you want.  Show
  \verb|[1,2,3]| syntax.  Show \verb|type| on lists.
\item Elements are ordered, in a sequence.  Indexed from zero.
\item Show \verb|range| function.
\item \verb|+|, \verb|*|, \verb|len()|, slices all work the same
\end{itemize}

\subsection*{Mutating lists}

Strings are \emph{immutable}, lists are \emph{mutable}.

\begin{verbatim}
animals = ['cat', 'dog', 'bird']
animals[1] = 'lemur'
print animals
\end{verbatim}
Draw a stack diagram of the above situation.

Other list mutation methods:
\begin{itemize}
\item \verb|t.append(element)| for adding to end
\item Removal:
  \begin{itemize}
  \item \verb|t.pop(index)| by index, returns deleted elt
  \item \verb|t.remove(element)| by element
  \item \verb|del t[index]| by index, doesn't return anything BUT
	\verb|del t[slice]| works too
  \end{itemize}
\end{itemize}

\section*{Lists II (Monday, 5 Oct)}

\subsection*{Setup}
\begin{itemize}
\item Music: Roomful of Teeth
\item Project 1 is graded.  Let us know of any questions.  Let me know
  if you want more feedback.
\item Hand out bit cards.
\end{itemize}

\subsection*{Review}
Find bit-2 partner. \verb|animals| is a list, how to append 3 copies
of \verb|"gerbil"| onto the end?  Go over possibilities.

\subsection*{Lists and strings}

Lists of characters are different than strings!

\begin{itemize}
\item Converting strings to list:
  \begin{itemize}
  \item \verb|list| function.
  \item \verb|split()| method.
  \end{itemize}
\item List to string: \verb|join()| method on delimiter.
\begin{verbatim}
  s = "banana"
  t = s.split("n")
\end{verbatim}
Yields \verb|["ba", "a", "a"]|.
\begin{verbatim}
  t = ['fun', 'sun', 'sub', 'rub']
  delimiter = " -> "
  delimiter.join(t)
\end{verbatim}
\end{itemize}

\subsection*{Mutability, objects, and aliasing}

Warm-up: what happens here?  Find bit-3 partner \& decide.
\begin{verbatim}
nums  = [1,2,3]
nums2 = nums
del nums[1]
print nums2
\end{verbatim}

Try it at IDLE prompt.  This is really weird.

As hinted last time, the fact that lists are mutable opens a huge can
of worms.  Let's start by pulling back the curtain a little bit.  Up
until now we have talked about variables having values, but we need to
be more precise.  Draw stack diagram with variables referencing two
different lists.  Write these definitions on the board:

\begin{itemize}
\item Variables reference \emph{objects} which have a \emph{value}.
\item Variables which reference objects that have the same value are
  \emph{equal}.  You can test equality with \verb|==|.
\item Variables which reference the \emph{same object} are
  \emph{identical}. You can test identity with \verb|is|.
\end{itemize}

Do this at the REPL, with accompanying pictures:
\begin{verbatim}
>>> a = [1,2,3]
>>> b = [1,2,3]
>>> a == b
True
>>> a is b
False
>>> del a[0]
>>> a
[2, 3]
>>> b
[1, 2, 3]
>>> a == b
False
>>> a = b
>>> a
[1, 2, 3]
>>> b
[1, 2, 3]
>>> a == b
True
>>> a is b
True
>>> del a[0]
>>> a
[2, 3]
>>> b
[2, 3]
\end{verbatim}
Note in particular that the assignment \verb|a = b| does not copy the
value of \verb|b| into \verb|a|, but just makes \verb|a|
\emph{reference the same thing as} \verb|b|.

This has implications for function parameters as well.  Consider:

\begin{verbatim}
def animal_release(animals):
  while len(animals) > 2:
  animals.pop(0)

print animals
animal_release(animals)
print animals
\end{verbatim}

Ask: what gets printed?  Draw stack diagram to understand.

Some related things:
\begin{itemize}
\item What if you really \emph{do} want to make a \emph{copy} of a
  list, so modifying it doesn't modify the original?  You can write
  \verb|some_list[:]|.  This is a dirty, terrible, disgusting hack.
  Perhaps someday you will understand why I feel this way.
\item Be careful about methods that modify vs functions that make a
  new thing.  e.g. \verb|list.sort()| modifies the list.  But
  \verb|sorted(list)| makes a new list!  And of course
  \verb|string.upper()| makes a new string because strings are
  immutable.  Confusing, don't memorize: the point is you should be
  careful and look up help to see what things do.  Show
  \verb|help(list.sort)|, \verb|help(sorted)|, \verb|help(str.upper)|.
\end{itemize}

[INSERT OPTIONAL RANT ABOUT MUTATION HERE]

\section*{For Loops (Wednesday, 7 Oct)}

\subsection*{Setup}
\begin{itemize}
\item Music:
\item Announce: exam 2 next Wednesday
\end{itemize}

\subsection*{For Loops}

Recall our \verb|explode| function from a week or two ago:
\begin{verbatim}
def explode(s):
  index = 0
  while index < len(s):
    print s[index]
\end{verbatim}
Recall how easy it was to make errors like starting index at the wrong
place, using \verb|<=| instead of \verb|<|, and so on.  Well, it turns
out there is a better way!
\begin{verbatim}
def explode(s):
  for c in s:
    print c
\end{verbatim}
Simply loops through each character in the string one at a time.  Each
time through the loop the next character is assigned to \verb|c|.
This also works for lists:
\begin{verbatim}
animals = ["cow", "chicken", "pig", "rabbit"]
for animal in animals:
  print "And on this farm he had a " + animal + "!"
\end{verbatim}
What do we lose, as compared to a \verb|while| loop?  The index. But
actually, we don't!  Just have to cleverly put together a few things
we have already seen:
\begin{verbatim}
for i in range(len(numbers)):
  numbers[i] *= 2
\end{verbatim}
This is way better than using a \verb|while| loop since it rules out
errors putting the starting or ending the indices at the wrong number.

\subsection*{For loop practice}

\begin{verbatim}
def print_each(s):
    index = 0
    while index < len(s):
        c = s[index]
        print(c)
        index += 1

def print_each_for(s):
    for c in s:
        print(c)

def count(s, c):
    num = 0
    for c2 in s:
        if c2 == c:
            num += 1
    return num

def find(s, c):
    for i in range(len(s)):
        if s[i] == c:
            return i
    return -1

def find_all(s, c):
    all_the_things = []
    for i in range(len(s)):
        if s[i] == c:
            all_the_things.append(i)
    return all_the_things

def nos(s):
    news = ""
    for c in s:
        if c != "s":
            news += c
    return news

def sum(t):
    total = 0
    for n in t:
        total += n
    return total

def mean(t):
    total = 0
    for n in t:
        total += n
    return float(total) / len(t)

def mean2(t):
    return float(sum(t)) / len(t)

def vacation(s):
    for i in range(len(s) - 1):
        if s[i] == s[i + 1]:
            return True
    return False

def classify(strs):
    for s in strs:
        print ('*' * len(s))

def powersof2(n):
    the_powers = []
    for i in range(n):
        the_powers.append(2 ** n)
    return the_powers

def triangle(n):
    total = 0
    for k in range(1,n+1):
        total += k
    return total
\end{verbatim}

\section*{For loop practice (Friday, 9 Oct)}

\subsection*{Setup}
\begin{itemize}
\item Music: Waltz for Debby
\item Pass out binary cards
\end{itemize}

\subsection*{For loops: reading exercises}

CLOSE COMPUTERS.
Find bit-partners. Different one for each exercise.
Go over each and try it.

\begin{verbatim}
def oogie(m):
    p = m[0]
    for g in m:
        if g > p:
            p = g
    return p

def yayaya(q):
    for y in range(len(q) - 1):
        if q[y] == q[y + 1]:
            return True
    return False

def pulu(r):
    b = []
    for k in range(r):
        b.append(k ** 3)
    return b
\end{verbatim}

\section*{Exam 2 review (Monday, 12 Oct)}

\section*{Exam 2 (Wednesday, 14 Oct)}

\section*{(Fall Break)}

\section*{Exam wrap-up, demo project (Monday, 19 Oct)}

\subsection{Exam wrap-up}

Hand back exams; quickly go over exam solutions.

\subsection{Demo project}

Introduce Project 2 (word games).

Livecode the beginning of an exemplary Doublets lab.  Things to focus
on:
\begin{itemize}
\item Start with \verb|main|.  Hierarchical decomposition; write stub
  functions.
\item Think about what information each function needs to do its job,
  and what information it returns.
\item Write \verb|get_starting_word| function.
\item Start writing \verb|get_ending_word| function, realize that they
  are going to have a lot of similar code.
\item Abstract common part out into a new function, \verb|get_word|,
  that takes a parameter describing the desired word.
\item Stub out a single round of the game, then talk about adding a
  while loop.
\end{itemize}

\section*{Recursion I: intro (Wednesday, 21 Oct)}

\subsection*{Setup}
\begin{itemize}
\item Write stone-counting rules somewhere (see below)?
\end{itemize}

\subsection*{Stone counting}

Rules:
\begin{enumerate}
\item You may not look inside the bowl.
\item You may only touch one stone.
\item If someone gives you the bowl and asks you how many stones it
  contains, you must eventually give the bowl back and answer
  truthfully.
\item You may give the bowl to someone else and ask them how many
  stones it contains.
\end{enumerate}
Hand the bowl to a student and ask how many stones it contains.

Recursion!  Functions that call themselves.  In a sense you were all
``the same function'' because you were running the same program
(rules).

Factorial function: $n! = 1 \times 2 \times \dots \times (n-1) \times
n$.  Let's implement in Python.
\begin{verbatim}
def fact(n):
    product = 1
    for k in range(1,n+1):
        product *= k
    return product
\end{verbatim}
Now consider $n! = (1 \times 2 \times \dots \times (n-1)) \times n =
(n-1)! \times n$.  Also need to define $0! = 1$.  Can we translate
this directly into Python?
\begin{verbatim}
def fact_rec(n):
    if n == 0:
        return 1
    else:
        result = fact_rec(n-1)
        return result * n
\end{verbatim}
It works!

Show call stack.  Every recursive call has its own copy of local
variables!

Big idea: transform a problem into a slightly simpler version, solve
that simpler problem, do a bit of work to compute an answer to the
original problem.

Typically:
\begin{itemize}
\item Base case(s): simple case where we know the answer without doing
  any work.  Always do this first!
\item Recursive case(s): make a recursive call to solve a slightly
  simpler (i.e. closer to the base case) problem.
\end{itemize}

Another example: Fibonacci function.  Show mathematical definition,
implement in Python.  Show how slow it is, show call tree.  In fact
recursion is not always the best way to do things.

If time, brief intro to Python turtle library and Kock snowflake (in
preparation for fractal lab).

\section*{Recursion II: recursive functions (Fri, 23 Oct)}

Start by reinforcing ``base case + recursive case''.  Talk about
``leap of faith'': trust that recursive calls will work without
thinking about how.  Trust your future self.

Re-code factorial function live, adding a bunch of comments and
narrating thought process.

Up until now all the examples we've done have been math functions.
Let's do a few more ``computer-sciency'' examples processing strings
and lists.  Note, in Python this is not the best way to implement
these functions (though in some languages it is).  Just for
illustration purposes.  If you take 151 you will start to see real,
legitimate uses of recursion, e.g. processing trees.

\begin{itemize}
\item Do example together: list sum.
\item Have them work in pairs to implement string \verb|reverse|.
\item Have them work in (different) pairs to implement \verb|is_palindrome|.
\end{itemize}

\section*{File I/O, dictionaries (intro) (Mon, 26 Oct)}

Our programs have no state between each time they are called.
Everything is stored in memory during the program, but afterwords,
it’s all gone.  This is RAM.  We need hard drive storage to keep it
around.  Save and read things in files.

To write to a file:

\begin{verbatim}
fout = open("myfile.txt", "w")
\end{verbatim}

then to save data in the file, write out as strings

\begin{verbatim}
fout.write("hello\n")
fout.write("world\n")
fout.close()
\end{verbatim}
Note the newline characters.

To read from a file:

\begin{verbatim}
fin = open("myfile.txt", "r")
\end{verbatim}

Two ways to get stuff out of the file.

\begin{verbatim}
s = fin.read()
\end{verbatim}

which returns a string that includes all the carriage returns, or

\begin{verbatim}
s = ""
for line in fin.readlines():
    s += line.strip()
\end{verbatim}

which strips them out of each line as it is added. \verb|readlines()|
returns a list of strings.

After both, say \verb|fin.close()| to finish accessing the file.

Then do basic intro to dictionaries?  Next time, need to figure out
some kind of activity to get them used to the idea.  Covering
technical details does not take 1.5 lectures.

\newpage

\section*{Dictionaries (Wed, 28 Oct)}

\subsection*{Setup}
\begin{itemize}
\item Music: Trio Medieval
\item HW: read Section 1 from Zen for Friday
\end{itemize}

Recall lists.  Draw an alternate picture of lists as a mapping from
indices to values. For example \verb|['tapir', 'ferret', 'alligator']|
can be thought of as
\begin{verbatim}
0 -> 'tapir'
1 -> 'ferret'
2 -> 'alligator'
\end{verbatim}
$0$, $1$, $2$ are \emph{keys}, animal names are \emph{values}.  A
\emph{mapping} or \emph{association} between keys and values.  A
\emph{dictionary} is the obvious generalization of this to arbitrary
keys instead of just 0, 1, 2 \dots.  For example, suppose we are
keeping these animals in a zoo and we want to keep track of them by
their habitat ID numbers.
\begin{verbatim}
'A23' -> 'tapir'
'B19' -> 'ferret'
'B12' -> 'alligator'
\end{verbatim}
Or we could use numbers as keys.  Important point: keys have to be
immutable.  So we can't use lists or dictionaries.

Show how to make this dictionary.
\begin{itemize}
\item Write using curly braces and colons.
\item Alternatively, start with empty one and add them.
\end{itemize}
Other things we can do with a dictionary:
\begin{itemize}
\item Get all keys with \verb|keys()|
\item Get all values with \verb|values()|
\item Check if a key is in the dictionary using \verb|in|
\item Ask for the number of keys with \verb|len|
\item Delete a mapping with \verb|del|
\item Iterate over keys with \verb|for|
\end{itemize}

Show
\url{https://docs.python.org/2.7/library/stdtypes.html#mapping-types-dict}.

Rewrite \verb|frequency_counts(s)| to return a dictionary.  Why this is
better: directly look up by letter value.  No need to use \verb|ord|
or alphabet string etc.

\begin{verbatim}
def frequency_counts(s):
    freqs = {}
    for c in s:
        if c not in freqs:
            freqs[c] = 0
        freqs[c] += 1

    normalize(freqs)
    return freqs

def normalize(d):
    total = 0
    for k in d:
        total += d[k]

    for k in d:
        d[k] /= float(total)
\end{verbatim}
Go over idea for \verb|proportional_choice| function on lab.

\section*{Zen Reading discussion (Friday, 30 Oct)}

\subsection*{Setup}

\begin{itemize}
\item HW: system analysis (see below)
\end{itemize}

\subsection*{Discussion}

somewhat confusing? yes.
you picked up in the middle of a journey the author is taking with his son
and friends across the country on a motorcycle
along the way he talks about the philosophy of quality, goodness, etc,
this excerpt is groundwork for that discussion
classical vs romantic understanding
underlying form vs appearance
negative views of each side (dull, uninteresting for classical, frivolous, erratic for romantic)
masculine vs feminine association? Sexist?
generous interpretations, because of culture? 70’s mentality?
in any case, this stereotype should not persist, obviously wrong
women can be engineers, men can be artists and have feelings
how is CSCI related to these understandings? Why did we read this?
classical, definitely
but elements of romantic too, creativity of solutions?
choices in problem solving, uniqueness of approaches to projects, labs
application of classical “analysis” to motorcycle
talk through some of the details of the diagrams
“impossible to understand unless you already know how one works”
knife diving up the motorcycle
intellectual scalpel
no two motorcycle manufacturers divide same way
romantic part of how this choice is made
this skill of using the knife has been what we have been practicing all semester
back to CSCI connection
when we have talked about data types, (int, bool, string, list, dict)
they have been ways we use the knife to separate information
they are all what we will now call OBJECTS
we want to make our own new datatypes for many different situations
two main pieces to make an object, components and functions, just like motorcycle above
hierarchies
component hierarchy
has-a relationship
eventually get to atomic elements (int, bool, string, list etc)
function hierarchy
is-a relationship
motorcycle is a vehicle
so is a bicycle, boat, truck, train, spaceship
all related by function
Your task as a team of 3 or four students
apply this analysis to a system
need more experience with using the knife in this way
first, list off the components
then think of some of their functions
what do they do
motorcycle – throttle up, brake, park, inflate tires, etc
how do the components communicate and pass information between themselves
how do they make the system work
not their existential purpose, not asking why right now, just how
then group into two different hierarchies
has-a
is-a
possible systems
airport, hospital, us government, zoo, farm, soccer game
see what they do
discussion on Monday of their analysis
which ones could we simulate with a computer,
what choices and divisions and hierarchies make this easier?

\subsection*{System analysis HW}

Split into groups of 3 or 4 (use binary cards), have each group choose
a system:

\begin{itemize}
\item Hospital
\item Soccer game
\item College class
\item US Government
\item Zoo
\item Airport
\end{itemize}

For Monday, analyze your system.
\begin{itemize}
\item Components?
\item Functions of components?
\item Information flow bewteen components?
\item Is-a hierarchy
\item Has-a hierarchy
\end{itemize}

Prepare a presentation, \emph{use projector} (don't waste time drawing
on board) and address all 5 of the above things.

\section*{System/hierarchy analysis presentations (Monday, 2 Nov)}

\section*{Intro to classes \& objects (Wednesday, 4 Nov)}

Birthday cake problem:
\begin{verbatim}
  # If n lit candles, blow out a random # between
  #   1 and n
  # How many blows does it take (on average)
  #   before they are all out?
\end{verbatim}

\begin{itemize}
\item Introduce idea of objects:
\begin{verbatim}
# We can package up data into "objects"
# Objects have functions, i.e. things they
#   can do. aka "Methods".

# Python "classes" allow us to design our
#   own new kinds of objects.
\end{verbatim}
\item Introduce idea of classes:
\begin{verbatim}
# class = template for objects
# an object is an "instance of" a class
# e.g. class = Car, object = my car
\end{verbatim}
\item Make empty \verb|Cake| class.
\item Show how we can make a \verb|Cake| object.
\item Show how we can set a variable, \verb|num_candles|, inside it.
  Draw stack/memory diagram.
\item Create an \verb|__init__| method with a parameter. (Explain
  \verb|self|; explain \verb|__init__|.)
\item Create \verb|blowout| and \verb|allout| methods.
\item Fill out the rest of the simulation:
\begin{verbatim}
class Cake:

    # __init__ is a special method
    #   that gets called when a
    #   new object is created.
    #   i.e. when Cake() is called.
    def __init__(self, num_candles):
        # self is a special first parameter
        # that gets filled in by Python

        # self.candles is a variable in the
        #   object being created
        #   (candles = ... would make a local var)
        self.candles = num_candles

    # Methods = things that all Cakes can do

    def blowout(self):
        n = random.randint(1, self.candles)
        self.candles -= n

    def allout(self):
        return (self.candles == 0)


def happy_birthday(c):
    count = 0
    while not c.allout():
        c.blowout()
        count += 1

    return count

def average_blows(num_candles, trials):
    total = 0
    for i in range(trials):
        c = Cake(num_candles)
        total += happy_birthday(c)
    return total / float(trials)

def main():
    for num_candles in range(100):
        print num_candles, average_blows(num_candles, 10000)

main()
\end{verbatim}
\item Run it and paste output into Excel, do a regression to show that
  it is close to natural log.
\end{itemize}

\section*{More classes \& objects (Friday, 6 Nov)}

Traffic light example.  Main point: encapsulation, abstraction.

\begin{verbatim}
# Traffic light
#
# How would you model it in Python?
# What functions should it have?
# How would it work?

# Possible functions:
#   - separate red, green, yellow light functions
#   - interval function
#   - sensor
#   - change to next color
#   - say what the current color is
#   - run
# Variables / state:
#   - current color
#   - timer (time left until next change?)


# Version 1:
#   - easy to write
#   - tedious (imagine cycling through 20 colors)
#   - difficult to change
class TrafficLight:

    # Variables:
    #   - current_color (string)

    # Create a new red traffic light
    def __init__(self):
        self.current_color = "RED"

    # Change to next color
    def change(self):
        if self.current_color == "RED":
            self.current_color = "GREEN"
        elif self.current_color == "GREEN":
            self.current_color = "YELLOW"
        elif self.current_color == "YELLOW":
            self.current_color = "ORANGE"
        elif self.current_color == "ORANGE":
            self.current_color = "RED"
        else:
            print "The sky is falling!!"  # This should never happen

    # Return the current color
    def color(self):
        return self.current_color

# Version 2:
# Use a dictionary of colors
class TrafficLight2:

    # Variables:
    #   - current_color
    #   - color_dict

    def __init__(self):
        self.current_color = "RED"
        self.color_dict = \
          { "RED" : "GREEN",
            "GREEN" : "YELLOW",
            "YELLOW" : "ORANGE",
            "ORANGE" : "RED" }

    def change(self):
        self.current_color = self.color_dict[self.current_color]

    def color(self):
        return self.current_color

# Version 3: list of colors
class TrafficLight3:

    # Variables:
    #   - color_list
    #   - current_index

    def __init__(self):
        self.color_list = ["RED", "GREEN", "YELLOW", "ORANGE"]
        self.current_index = 0

    def change(self):
        self.current_index += 1
        self.current_index %= len(self.color_list)

    def color(self):
        return self.color_list[self.current_index]

def main():
    t = TrafficLight3()
    print t.color()
    for i in range(10):
        t.change()
        print t.color()

main()
\end{verbatim}

\section*{Yet More classes \& objects (Monday, 9 Nov)}

Mechanical pencil exercise.  Have them work in teams to code a class
representing a mechanical pencil.  Paste code into Google doc, look
through it together.

\section*{Yet Even More classes \& objects (Wednesday, 11 Nov)}

Card and Deck examples.
\begin{itemize}
\item Make \verb|Card| class with \verb|rank|, \verb|suit| (strings),
  and \verb|face_up| (boolean).  Though can leave \verb|face_up| until
  later.  Just has getter methods.  Write \verb|__repr__|. (If usung
  \verb|face_up|, \verb|__repr__| should return \verb|**| or something
  like that if face down.)
\item Start making \verb|Deck| class with list of cards.  Make
  \verb|__init__| (create 52-card deck), \verb|shuffle| (use
  \verb|random.shuffle|), \verb|draw| (draw one card), \verb|deal(n)|
  (draw $n$ cards)
\end{itemize}

\section*{Still Yet Even More classes \& objects (Friday, 13 Nov)}

Finish Deck, make Hand, Player, HumanPlayer, ComputerPlayer.

\section*{Fill in stuff!}

\section*{Queues}

I usually start with a discussion of the queue data structure itself and
why it would be useful. We might want to model lines of people in the
supermarket or at a bank, and determine why each has a different way of
organizing people (multiple lines with one checkout person each, vs one
line with multiple tellers).

I then walk through the methods of a queue
(\verb|add, remove, size, is_empty|) and some important words (front,
back) and write up the super class Queue with all the method bodies
being “pass”.

Easiest way to implement a queue is to use a list, in terms of lines of
code. List already do everything we need, and we’re just constraining the
interactions to be with the front [0] and back [-1]. We code up the
ListQueue class together.

Then we test the ListQueue with the tester function and the main function.
As we put stress on the queue with larger numbers, we see it’s not a linear
relationship, but quadratic. 10 ** 7 is a good number to stop, since it
takes about 100 seconds to complete. I haven’t in the past, but I think I
will make a log-log plot of the size vs the time.

So, maybe a list, because it is very flexible and can access any element,
is too much for this Queue task, and we could do better with another way of
implementing a Queue where we only really care about the front and back.

Then, I discuss the Node abstraction. Break up a list into individual
pieces that fit together like Legos. It’s a recursive data type, something
that stores an element and another Node as components.  This requires a
discussion of the word None. We’ve seen it as the return value of a void
function. Python has a word for “nothing”, and we can use that word when we
need a variable but it has no value.

Conveniently, we can calculate the size of a Node with a very simple
recursive function.

How do we use this to make a Queue? Make the NodeQueue class, and have two
components in init, the front and back, which start off as None.

Write size, very simple,  and \verb|is_empty|, base it on self.front being empty.

First, I try to complete add and remove the natural, but wrong, way. A node
is then someone standing in line. When people stand in lines, they look at
the person in front of them. So we start with the \verb|is_empty| case, and set
set.front = Node(e) and self.back = self.front. This is ok.

We then write the case when there are already people in line. We have a new
element to add to the back, so we write

temp = Node(e)
temp.next = self.back
self.back = temp

to reset the back pointer. All looks good so far.

But we can’t remove people from the queue easily. We can get the element we
need from self.front, but who is the next self.front? self.front.next ==
None, and this is a problem. We could walk from the back to get the element
right behind self.front, with complicated two-finger algorithm, and it
takes a long time. Booo.

So instead, we reverse the orientation of everyone in line. You stand in
line backwards and stare at the person behind you. They are your next. If
you do this in real life, people will get a little uncomfortable. Just go
with it, computer scientists are weird sometimes because it’s the right
thing to do, like starting to count at 0…

Then we rewrite add to match the code in the queuestuff.py file, and
finally we can write a remove method, to set self.front = self.front.next.
Both are now constant time.

How does this fare with our tests? For small numbers, a little more
expensive. The overhead of making new Node objects all the time is seen.

But as it gets larger, the time is linear with the size. for 10 ** 6 and
beyond, NodeQueue will beat ListQueue hands down. You can go back to plot
them in excel.  I’ve included an image in the code directory of these two
lines on the log-log plot.

I finish with discussing how this analysis and construction of data
structures is at the core of the science part of computer science, and will
be heavily discussed in CSCI 151 with more formal tools and for more
complicated structures, within the context of Java.
\end{document}

